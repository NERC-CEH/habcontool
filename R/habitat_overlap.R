#' DISCLAIMER: This documentation was generated by ChatGPT.
#' Please review and edit as needed to ensure accuracy and completeness.
#'
#' Identify Habitat Overlaps and Connectivity
#'
#' Processes spatial habitat data to identify overlaps, connectivity, and areas for potential habitat linkage. 
#' Supports combining polygons, buffering, and converting spatial data into raster format.
#'
#' @param spatial_object `sf` object containing the habitat polygons to analyze.
#' @param habitat_column_name `character` Column name in the `spatial_object` that identifies habitat types or groups. Used to identify if joined polygons were the same or different habitats.
#' @param extent `numeric` Vector of four values (`xmin`, `ymin`, `xmax`, `ymax`) defining the region of interest. Defaults to `NULL` (no cropping).
#' @param buffer_distance `numeric` Distance (in meters) for buffering the polygons.
#' @param connection_distance `numeric` Distance (in meters) used to determine connectivity between polygons.
#' @param min_core_area `numeric` Minimum area of "core" (i.e. contiguous) habitat. If not `NULL`, filters out polygons smaller than this value before combining polygons within `connect_dist` of each other. Defaults to `NULL`.
#' @param min_area `numeric` Minimum area (in square meters) required to retain polygons. Smaller polygons are filtered out. No default, must be specified.
#' @param combine_touching_polys `logical` Whether to combine polygons that touch. Defaults to `TRUE`.
#' @param combine_close_polys `logical` Whether to combine polygons within `connection_distance`. Defaults to `FALSE`.
#' @param plot_it `logical` Whether to generate and display diagnostic plots at each step. Defaults to `TRUE`.
#' @param resolution `numeric` Resolution of the output raster, specified as a vector of two values. Defaults to `c(10, 10)`.
#' @param quiet `logical` Whether to print progress messages.
#'
#' @return A `list` containing:
#' \itemize{
#'   \item `combined_object`: `sf` object of the combined polygons.
#'   \item `buffered_object`: `sf` object of the buffered polygons with overlap counts.
#'   \item `buffered_raster_stack`: Raster stack showing buffered polygons.
#'   \item `buffered_raster_overlaps`: Raster showing the sum of overlaps across buffered polygons.
#'   \item `habitat_connectivity_raster`: Raster identifying regions of potential habitat connectivity.
#' }
#'
#' @importFrom sf st_crop st_area st_geometry st_buffer st_intersects
#' @importFrom ggplot2 ggplot geom_sf theme_bw ggtitle scale_fill_viridis_d geom_tile coord_quickmap
#' @importFrom terra rast ext values
#' @importFrom units set_units
#' @examples
#' \dontrun{
#' result <- habitat_overlap(
#'   spatial_object = habitat_data,
#'   habitat_column_name = "habitat_type",
#'   extent = c(1000, 2000, 1000, 2000),
#'   buffer_distance = 500,
#'   connection_distance = 500,
#'   min_area = 1000,
#'   combine_touching_polys = TRUE,
#'   combine_close_polys = TRUE,
#'   plot_it = TRUE,
#'   resolution = c(10, 10)
#' )
#' }
#' @export
habitat_overlap <- function(spatial_object, 
                            habitat_column_name = NULL, 
                            extent = NULL, 
                            buffer_distance,
                            connection_distance, 
                            min_area = NULL,
                            combine_touching_polys = TRUE, 
                            min_core_area = NULL,
                            combine_close_polys = FALSE,
                            return_sf = FALSE,
                            plot_it = TRUE, 
                            resolution = c(10,10),
                            quiet = FALSE) {
  
  # crop to region of interest
  if(!is.null(extent)) {
    
    if(!quiet)
      message('!! cropping object')
    object <- sf::st_crop(spatial_object, extent)
    
  } else if(is.null(extent)) object <- spatial_object
  
  if(dim(object)[1] == 0) stop('!! No polygons present in area. Increase extent size or change area.')
  
  # set units to metres for use in the buffering functions
  if(!inherits(buffer_distance, "units")) {
    if(!quiet) 
      message("assuming 'buffer_distance' is provided in metres")
    buffer_dist <- units::set_units(buffer_distance, 'm')
  }
  
  if(!inherits(connection_distance, "units")) {
    if(!quiet)
      message("assuming 'connection_dist' is provided in metres")
    connection_dist <- units::set_units(connection_distance, 'm')
  }
  
  if(!is.null(min_area)){
    if(class(min_area) != "units") {
      if(!quiet)
        message("assuming 'min_area' is provided in metres^2")
      min_area <- units::set_units(min_area, 'm^2')
    }
  }
  
  if(!is.null(min_core_area)){
    if(class(min_core_area) != "units") {
      if(!quiet)
        message("assuming 'min_core_area' is provided in metres^2")
      min_core_area <- units::set_units(min_core_area, 'm^2')
    }
  }
  
  # Combine touching polygons and those within connection_dist if combine_close == TRUE
  if(combine_touching_polys) {
    
    if(!quiet)
      message('!! combining touching and/or close polygons')
    
    # run function
    comb_object <- combine_touching(comb_obj = object, 
                                    variable_name = habitat_column_name,
                                    min_core_area = min_core_area,
                                    Plot = FALSE, connect_dist = connection_dist, 
                                    combine_close = combine_close_polys)
    
  } else if (!combine_touching_polys) {
    
    comb_object <- object
    comb_object$poly_id <- as.character(seq(1:nrow(comb_object)))
    
  }
  
  # filter minimum area 
  if(!is.null(min_area)){
    obj_lrge <- comb_object %>% 
      dplyr::mutate(area = st_area(st_geometry(.))) %>% 
      dplyr::filter(area > min_area)
  } else { obj_lrge <- comb_object }
  
  
  if(!quiet)
    message('!! Buffering polygons')
  
  ## Buffer, calculate number of overlaps (n_overlaps), and number within double
  ## of the buffer specified.
  obj_lrge_buff <- sf::st_buffer(obj_lrge, dist = buffer_dist) %>% 
    dplyr::mutate(n_overlaps = lengths(st_intersects(.)))  
  
  # convert buffered polygon to raster - produces a raster stack with 1s in every non-0 cell
  # for each layer in the raster. Raster should be projected. Can also be given the name
  # of the column in the sf polygon ('field' in the rasterize() function) - to retain values
  # associated with the polygon
  if(!is.null(habitat_column_name)) {
    buffered_object_rast <- poly_to_rast(obj = obj_lrge_buff, 
                                         field_val = 1, 
                                         resolution = as.numeric(resolution), 
                                         rast_extent = terra::ext(obj_lrge_buff)+10, 
                                         layer_names = obj_lrge_buff$variable)
  } else {
    buffered_object_rast <- poly_to_rast(obj = obj_lrge_buff, 
                                         field_val = 1, 
                                         resolution = as.numeric(resolution), 
                                         rast_extent = terra::ext(obj_lrge_buff)+10, 
                                         layer_names = NULL)
  }
  
  # check that the polygon names are in the same order
  if(!identical(obj_lrge_buff$poly_id, obj_lrge$poly_id)) stop("! polygons aren't in same order")
  
  # take the sum across all layers to get the overlaps (where value > 1)
  buff_obj_sum <- sum(buffered_object_rast, na.rm = TRUE)
  names(buff_obj_sum) <- "n_overlaps"
  
  ## remove the original polygons from the raster to identify areas for habitat connectivity
  # convert original polygon into raster layer - set field to -1 to identify overlapping regions
  
  # convert original polygon into raster layer.
  # set field to -1 to distinguish them from the empty areas in the raster
  # (i.e. areas with no polygons in them)
  if(!is.null(habitat_column_name)) {
    obj_lrge_rast <- sum(poly_to_rast(obj_lrge, field_val = -1, 
                                      resolution = as.numeric(resolution), 
                                      rast_extent = terra::ext(obj_lrge_buff)+10, 
                                      layer_names = obj_lrge$variable), 
                         na.rm = TRUE)
  } else {
    obj_lrge_rast <- sum(poly_to_rast(obj_lrge, field_val = -1, 
                                      resolution = as.numeric(resolution), 
                                      rast_extent = terra::ext(obj_lrge_buff)+10, 
                                      layer_names = NULL), 
                         na.rm = TRUE)
  }
  
  # set any areas that == 0 to 1
  # When multiplying this by the overlapping areas, this will turn any areas overlapping
  # with the original objects negative, but leave everything else the same
  terra::values(obj_lrge_rast)[is.na(terra::values(obj_lrge_rast))] <- 1
  
  # multiply new raster with buffered object with overlaps - negative values are
  # where they overlap
  overlaps_only <- buff_obj_sum*obj_lrge_rast
  
  # Set anything <=1 to NA (areas where they overlap original polygon and 
  # where there's only one buffered region)
  terra::values(overlaps_only)[terra::values(overlaps_only)<=1] <- NA
  names(overlaps_only) <- "n_overlaps"
  
  if(plot_it){
    
    p1 <- ggplot() +
      geom_sf(data = object) +
      theme_bw() +
      ggtitle('Initial object')
    
    p2 <- ggplot() +
      geom_sf(data = obj_lrge, aes(fill = poly_id)) +
      theme_bw() +
      ggtitle(ifelse(combine_touching_polys, 'Combined objects by ID', 'Initial object by ID')) +
      scale_fill_viridis_d() +
      theme(legend.position = 'none')
    
    p3 <- ggplot() +
      geom_raster(data = as.data.frame(buff_obj_sum, xy=TRUE), 
                  aes(x=x, y=y, fill = n_overlaps), alpha = 0.5) +
      geom_sf(data = obj_lrge) +
      theme_bw() +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank()) +
      scale_fill_viridis_c(na.value = NA, name = 'Overlaps') +
      ggtitle('Buffered initial object')
    
    p4 <- ggplot() +
      geom_sf(data = obj_lrge) +
      geom_tile(data = as.data.frame(overlaps_only, xy=TRUE), 
                aes(x=x, y=y, fill = n_overlaps), alpha = 0.5) +
      theme_bw() +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank()) +
      scale_fill_viridis_c(na.value = NA, name = 'Overlaps') +
      ggtitle('Overlapping regions only')
    
    print(p1+p2+p3+p4)
    
  }
  
  return(list(combined_large_object = obj_lrge,
              buffered_object = obj_lrge_buff,
              buffered_raster_stack = buffered_object_rast,
              buffered_raster_overlaps = buff_obj_sum,
              habitat_connectivity_raster = overlaps_only))
  
}

