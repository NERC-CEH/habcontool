#' DISCLAIMER: This documentation was generated by ChatGPT.
#' Please review and edit as needed to ensure accuracy and completeness.

#' Combine Polygons That Touch or Are Close
#'
#' Combines polygons in a spatial object that either touch or are within a specified distance of each other.
#'
#' @param comb_obj `sf` object containing the polygons to combine.
#' @param variable_name `character` Name of the column used for grouping polygons. If `NULL`, polygons are combined without keeping the habitat type. Defaults to `NULL`.
#' @param min_core_area `numeric` Minimum area of "core" (i.e. contiguous) habitat. If not `NULL`, filters out polygons smaller than this value before combining polygons within `connect_dist` of each other. Defaults to `NULL`.
#' @param combine_close `logical` Whether to combine polygons that are within `connect_dist` of each other. Defaults to `TRUE`.
#' @param connect_dist `numeric` Distance threshold for combining polygons (in spatial units). Defaults to `100`.
#' @param Plot `logical` Whether to plot the combined polygons. Defaults to `TRUE`.
#'
#' @return An `sf` object with combined polygons and updated grouping information.
#' @importFrom sf st_union st_intersects st_cast
#' @importFrom ggplot2 ggplot geom_sf theme_bw ggtitle theme
#' @examples
#' \dontrun{
#' combined <- combine_touching(spatial_data, "habitat_type", TRUE, 200, TRUE)
#' }
#' @export
combine_touching <- function(comb_obj, 
                             variable_name = NULL, 
                             min_core_area = NULL,
                             combine_close = TRUE, 
                             connect_dist = 100, 
                             Plot = TRUE) {
  
  if(!inherits(comb_obj, "sf")) stop("'comb_object' must be of class 'sf'")
  if(!is.null(variable_name) && !variable_name %in% colnames(comb_obj)) 
    stop("'variable_name' must be a column name (as character) found in 'comb_obj' or NULL")
  
  # combine overlapping polygons by casting all multipolygons to polygons
  # check for intersections between that and original object
  # unlist the IDs to use as a grouping column
  parts <- st_cast(st_union(comb_obj),"POLYGON")
  int <- st_intersects(comb_obj, parts)
  clust <- unlist(lapply(1:length(int), function(x) paste(int[[x]], collapse = '_')))
  
  # group by the column and join the overlapping objects together
  if(!is.null(variable_name)) {
    
    comb_obj$variable <- data.frame(comb_obj)[,variable_name]
    
    diss <- cbind(comb_obj, clust) %>%
      dplyr::group_by(clust) %>%
      dplyr::summarise(variable = paste(unique(variable), collapse = ', ')) %>% 
      dplyr::rename('poly_id' = 'clust')
    
  } else if(is.null(variable_name)) {
    
    diss <- cbind(comb_obj, clust) %>%
      dplyr::group_by(clust) %>%
      dplyr::summarise() %>% 
      dplyr::rename('poly_id' = 'clust')
    
  }
  
  
  # filter minimum core area 
  if(!is.null(min_core_area)){
    diss <- diss %>% 
      dplyr::mutate(area = st_area(st_geometry(.))) %>% 
      dplyr::filter(area > min_core_area)
    diss$area <- NULL
    
    if(dim(diss)[1]==0)
      stop(paste("!! No polygons are larger than 'min_core_area'", min_core_area))
  } 
  
  
  # Combine polygons that are close to consider them as a single polygon
  # habitats within connect_dist are already considered as one because species
  # can already use them
  if(combine_close){
    
    # use my own function to determine which objects are within connection_distance of
    # each other - produces an id of all objects within that distance.
    # Works with finding patches that are linked to other ones via intermediate habitats
    int_within_dist_id <- is_within_dist(sf_obj = diss, connect_dist = connect_dist)
    
    # use the ID to combine the polygons
    if(!is.null(variable_name)) {
      
      diss <- cbind(diss, int_within_dist_id) %>%
        dplyr::group_by(int_within_dist_id) %>%
        dplyr::summarise(variable = paste(unique(variable), collapse = ', ')) %>% 
        dplyr::rename('poly_id' = 'int_within_dist_id')
      
    } else if(is.null(variable_name)) {
      
      diss <- cbind(diss, int_within_dist_id) %>%
        dplyr::group_by(int_within_dist_id) %>%
        dplyr::summarise() %>% 
        dplyr::rename('poly_id' = 'int_within_dist_id')
      
    }
    
  }
  
  if(Plot){
    
    p <- diss %>% 
      ggplot() +
      geom_sf(aes(fill = poly_id)) +
      theme_bw() +
      ggtitle('Combined polygons') +
      theme(legend.position = 'none')
    print(p)
    
  }
  
  return(diss)
  
}


#' Filter Polygons by Minimum Area
#'
#' Filters polygons in a spatial object to retain only those with an area above a specified threshold.
#'
#' @param spatial_object `SpatRaster` or `sf` object containing polygons to filter.
#' @param min_area `numeric` Minimum area (in square meters) to retain a polygon.
#' @param combine_output_rast `logical` Combine touching polygons prior to removing small polygons?Defaults to `TRUE`.
#' @param return_rast `logical` If `TRUE` a raster is returned, otherwise an `sf` object is returned. Defaults to `TRUE`.
#' @param combine_output_rast `logical` Should the final raster be combined into one, or left as individual layers? If `TRUE`, the maximum of overlapping regions is taken. Defaults to `TRUE`.
#' @param quiet `logical` Suppress messages. Defaults to `TRUE`.
#'
#' @return An `sf` object containing polygons that meet the area requirement.
#' @importFrom sf st_area st_cast st_as_sf
#' @examples
#' \dontrun{
#' large_polygons <- filter_min_area(spatial_data, 500)
#' }
#' @export
filter_min_area <- function(spatial_object, 
                            min_area,
                            combine_touching_polys = TRUE,
                            return_rast = TRUE,
                            combine_output_rast = TRUE,
                            quiet = TRUE) {
  
  # ensure min_area has units
  if(!is.null(min_area)){
    if(class(min_area) != "units") {
      if(!quiet)
        message("assuming 'min_area' is provided in metres^2")
      min_area <- units::set_units(min_area, 'm^2')
    }
  }
  
  # convert to polygons
  connect_poly <- rast_to_poly(spatial_object)
  
  # get area
  connect_poly$area <- sf::st_area(connect_poly)
  
  if(combine_touching_polys) {
    
    # Combine touching polygons while maintaining the number of
    # overlaps in each polygon - can't use combine_touching
    # find polygons that are touching each other
    parts <- st_cast(st_union(connect_poly),"POLYGON")
    int <- st_intersects(connect_poly, parts)
    clust <- unlist(lapply(1:length(int), function(x) paste(int[[x]], collapse = '_')))
    connect_poly$polyid_after_combining <- clust
    
    # get area of polygons that are touching combined
    connect_poly <- connect_poly %>% 
      dplyr::group_by(polyid_after_combining) %>% 
      dplyr::mutate(area = sum(area, na.rm = TRUE)) %>% 
      dplyr::ungroup()
    
  } 
  
  lrge_connects <- connect_poly[connect_poly$area>min_area,]
  
  if(dim(lrge_connects)[1] == 0)
    stop(paste("!! No polygons are larger than", min_area))
  
  if(return_rast){
    lrge_connects <- poly_to_rast(obj = lrge_connects, 
                                  field_val = lrge_connects$n_overlaps, 
                                  resolution = terra::res(spatial_object), 
                                  rast_extent = terra::ext(spatial_object), 
                                  layer_names = NULL)
    
    if(combine_output_rast){
      # check to make sure there are no overlapping rasters 
      if(any(terra::values(terra::app(lrge_connects, function(x) rowSums(!is.na(x))))>1))
        warning("!! Overlapping areas were generated by conversion from sf to spatRast (this shouldn't happen). 
              The number of overlaps might not be accurate.")
      
      # combine all layers into one
      lrge_connects <- max(lrge_connects, na.rm = TRUE)
    }
  }
  
  return(lrge_connects)
  
}


#' Get Extremes of a Polygon's Coordinates
#'
#' Identifies the outermost coordinates (min/max x and y) of a polygon.
#'
#' @param sf_poly `sf` object representing the polygon.
#'
#' @return A `data.frame` with columns `x_min`, `x_max`, `y_min`, and `y_max`.
#' @importFrom sf st_coordinates st_cast
#' @examples
#' \dontrun{
#' extremes <- get_poly_extremes(polygon_data)
#' }
#' @export
get_poly_extremes <- function(sf_poly) {
  coord_box <- data.frame(st_coordinates(st_cast(st_cast(sf_poly, 'MULTIPOLYGON'), 'POLYGON')))
  
  c(xmin = min(coord_box$X), 
    ymin = min(coord_box$Y), 
    xmax = max(coord_box$X), 
    ymax = max(coord_box$Y))
}



#' Identify Objects Within a Distance
#'
#' Determines which objects in an `sf` object are within a specified distance of each other.
#'
#' @param sf_obj `sf` object containing the spatial data.
#' @param connect_dist `numeric` Distance threshold (in spatial units) to identify connections.
#'
#' @return A character vector where each element is an identifier for groups of objects within the specified distance.
#' @importFrom sf st_is_within_distance
#' @examples
#' \dontrun{
#' within_dist_ids <- is_within_dist(spatial_data, 200)
#' }
#' @export
is_within_dist <- function(sf_obj, connect_dist){
  
  # identify patches within distance
  win_dist <- st_is_within_distance(sf_obj, dist = connect_dist)
  
  # Find objects that have matching numbers
  # to use as a grouping variable. Loop through each ID in turn and look
  # for all matching values in other IDs
  for(i in 1:length(win_dist)) { 
    for(j in 1:length(win_dist)) {
      if(any(win_dist[[i]] %in% win_dist[[j]])) {
        
        id_vals <- sort(unique(c(win_dist[[i]], win_dist[[j]])))
        
        win_dist[[i]] <- id_vals
        win_dist[[j]] <- id_vals
        
      }
    }
  }
  
  # condense id into single, sorted, id col
  within_dist_id <- sapply(win_dist, FUN = function(i) paste(sort(i), collapse = '_'))
  return(within_dist_id)
}


#' Convert Polygons to Raster
#'
#' Converts polygons into a raster format with specified resolution and optional extent.
#'
#' @param obj `sf` object containing polygons to convert.
#' @param field_val `numeric` or `character` Field value(s) to assign to the raster cells.
#' @param resolution `numeric` Vector of two values specifying raster resolution (e.g., `c(10, 10)`).
#' @param rast_extent `SpatExtent` Optional extent for the raster. Defaults to `NULL`.
#' @param layer_names `character` Optional names for the raster layers.
#'
#' @return A `SpatRaster` object.
#' @importFrom terra rast vect ext rasterize
#' @examples
#' \dontrun{
#' raster <- poly_to_rast(polygon_data, field_val = 1, resolution = c(10, 10))
#' }
#' @export
poly_to_rast <- function(obj, field_val = 1, resolution = c(10,10), 
                         rast_extent = NULL, layer_names = NULL) {
  
  if(!inherits(resolution, "numeric"))
    resolution <- as.numeric(resolution)
  
  if((abs(st_bbox(obj)$xmax-st_bbox(obj)$xmin) < resolution[1]) |
     (abs(st_bbox(obj)$ymax-st_bbox(obj)$ymin) < resolution[2]))
    stop("!! The specified resolution is greater than the range of X or Y values in the supplied object.
          !! Reduce the resolution. 
          !! Remember that the resolution is on the same scale as the coordinates system you're using.")
  
  
  # convert raster to spatial format
  buffered_object_points <- terra::vect(obj)
  
  # from this, create a template raster to fill
  # if extent not provided then create own based on the buffered object
  if(is.null(rast_extent)) {
    template_rast <- terra::rast(crs = as.character(terra::crs(buffered_object_points)), 
                                 extent = terra::ext(buffered_object_points),
                                 vals = 0, resolution = resolution)
  } else {
    template_rast <- terra::rast(crs = as.character(terra::crs(buffered_object_points)),
                                 extent = terra::ext(rast_extent),
                                 vals = 0, resolution = resolution)
  }
  
  # fill the template with the points above, giving the values in the 'n_overlaps' column
  
  if(length(field_val) == 1) {
    buffered_object_rast <- terra::rast(
      lapply(1:nrow(buffered_object_points), 
             FUN = function(x) terra::rasterize(buffered_object_points[x,], 
                                                template_rast, field = field_val))
    )
  } else if(length(field_val)>1) {
    buffered_object_rast <- terra::rast(
      lapply(1:nrow(buffered_object_points), 
             FUN = function(x) terra::rasterize(buffered_object_points[x,], 
                                                template_rast, field = field_val[x]))
    )
  }
  
  if(!is.null(layer_names)) names(buffered_object_rast) <- layer_names
  
  return(buffered_object_rast)
  
}



#' Convert a Single-Layer Raster to Polygon
#'
#' DISCLAIMER: This documentation and the associated function were generated by ChatGPT. 
#' Please verify and adapt the function to suit your specific requirements and data.
#'
#' This function converts a single-layer raster object into a polygon (or multipolygon) representation. 
#' It ensures proper handling of geometries by casting multipolygons into polygons where necessary.
#'
#' @param raster A single-layer raster object to be converted into a polygon. 
#'   The raster should be a valid `terra` object.
#'
#' @return An `sf` object representing the polygon (or multipolygon) geometry converted from the input raster.
#'
#' @examples
#' \dontrun{
#' library(terra)
#' # Example raster creation
#' example_raster <- rast(matrix(1:9, nrow = 3, ncol = 3))
#' # Convert raster to polygon
#' polygon <- rast_to_poly(example_raster)
#' }
#'
#' @importFrom terra as.polygons
#' @importFrom sf st_cast st_as_sf
#'
#' @export
rast_to_poly <- function(raster) {
  
  rast_vect <- terra::as.polygons(raster)
  
  # st_cast() doesn't work properly if sf object contains polygons and 
  # multipolygons - convert to multipolygon first before converting to poly
  rast_multipoly <- sf::st_cast(st_as_sf(rast_vect), 'MULTIPOLYGON')
  rast_poly <- sf::st_cast(rast_multipoly, 'POLYGON')
  
  return(rast_poly)
}


#' Create Grids with Buffer Zones
#'
#' DISCLAIMER: This documentation and the associated function were generated by ChatGPT. 
#' Please verify and adapt the function to suit your specific requirements and data.
#'
#' WARNING: Ensure the `spatial_object` is appropriately projected and aligned with the desired 
#' coordinate system for accurate grid creation and buffering.
#'
#' This function creates a grid of specified size over a given spatial object and generates a buffered 
#' version of the grid. It also extracts the bounding box values for both the central grid and the 
#' buffered grid to define regions of interest.
#'
#' @param spatial_object An `sf` object representing the spatial region over which the grid will be created.
#' @param grid_size Numeric. The size of each grid cell in map units (default is `10000`).
#' @param clip_to_poly Binary. Whether to return only grids overlapping the polygon.
#' @param grid_buffer_size Numeric. The buffer distance applied to each grid cell in map units 
#'   (default is equal to `grid_size`).
#' @param return_format The class of object to return. One of c("sf", "extent", "wkt")
#'
#' @return A list containing two elements:
#'   \item{central_grid}{A list of bounding boxes representing the central grid cells.}
#'   \item{buffered_grid}{A list of bounding boxes representing the buffered grid cells.}
#'
#' @examples
#' \dontrun{
#' library(sf)
#' # Example spatial object
#' example_object <- st_as_sf(st_bbox(c(xmin = 0, xmax = 100000, ymin = 0, ymax = 100000), crs = 4326))
#' # Create grids
#' grids <- create_grids(example_object, grid_size = 5000, grid_buffer_size = 6000)
#' }
#'
#' @importFrom sf st_make_grid st_buffer
#'
#' @export
create_grids <- function(spatial_object,
                         grid_size = 10000,
                         # grid_buffer_size = grid_size,
                         clip_to_poly = TRUE,
                         return_format = "sf") {
  
  if(!inherits(spatial_object, "sf"))
    stop("'spatial_object' must be of class 'sf'")
  
  # create the grid using sf
  spat_grid <- sf::st_make_grid(spatial_object,
                                cellsize = grid_size)
  
  # #### remove the buffered region - no longer needed!!!!!
  # spat_grid_buff <- sf::st_buffer(spat_grid,
  #                                 dist = grid_buffer_size,
  #                                 endCapStyle = 'FLAT',
  #                                 joinStyle = "MITRE")
  
  if(clip_to_poly){
    
    spat_grid <- spat_grid[apply(st_intersects(spat_grid, spatial_object, sparse = FALSE), 1, any),]
    
  }
  
  
  if(any(grepl("extent", return_format))){
    
    # get the x-y min max values to define our central region of interest
    extent_grid <- (lapply(1:length(spat_grid), FUN = function(x) {
      get_poly_extremes(spat_grid[x])
    }))
    
    return(extent_grid)
  } else if(any(grepl("wkt", return_format))) {
    
    wkt_list <- st_as_text(spat_grid)
    
    return(wkt_list)
    
  } else if(any(grepl("sf", return_format))) {
    
    return(spat_grid)
    
  } else 
    stop("! Return format must be one of c('sf', 'extent', 'wkt'')")
  
}


#' Combine Overlapping Gridded Rasters
#'
#' DISCLAIMER: This documentation and the associated function were generated by ChatGPT. 
#' Please verify and adapt the function to suit your specific requirements and data.
#' 
#' This function reads all raster files from a specified folder, mosaics them using a specified function, and optionally saves the output.
#'
#' @param rast_folder Character. Path to the folder containing raster files.
#' @param fun Character. The function used to combine overlapping rasters (e.g., `"max"`, `"mean"`, `"sum"`). Default is `"max"`.
#' @param write Logical. Whether to save the resulting raster. Default is `TRUE`.
#' @param save_loc Character. Path to the folder where the output raster will be saved. Required if `write = TRUE`.
#'
#' @return A `SpatRaster` object representing the mosaicked raster.
#' 
#' @details 
#' - The function lists all raster files in `rast_folder` and creates a spatial collection.
#' - It then mosaics the rasters using the specified function (`fun`).
#' - If `write = TRUE`, the function creates the `save_loc` directory (if not existing) and saves the result as a `.tif` file.
#'
#' @examples
#' \dontrun{
#' combine_overlap_gridded("path/to/rasters", fun = "mean", write = TRUE, save_loc = "path/to/save")
#' }
#'
#' @import terra
#' @export
combine_overlap_gridded <- function(rast_folder,
                                    fun = "max",
                                    min_hab_area = NULL,
                                    write = TRUE,
                                    return_rast = TRUE,
                                    save_loc = NULL) {
  
  # list the rasters in the folder
  rasts <- list.files(rast_folder, full.names = TRUE)
  
  # create a spatial collection
  message("! creating spatial collection")
  rast_sprc <- terra::sprc(rasts)
  
  # mosaic according to function
  message("! creating mosaic")
  rast_comb <- terra::mosaic(rast_sprc, fun = fun)
  
  # filter the minimum area and end up converting to polygons
  if(!is.null(min_hab_area)) {
    
    rast_comb <- filter_min_area(spatial_object = rast_comb,
                                 min_area = min_hab_area,
                                 combine_touching_polys = TRUE,
                                 return_rast = return_rast,
                                 combine_output_rast = TRUE,
                                 quiet = TRUE)
    
  }
  
  if(write){
    
    message("! saving")
    
    dir.create(save_loc, showWarnings = FALSE, recursive = TRUE)
    
    terra::writeRaster(rast_comb, paste0(save_loc, "/", basename(rast_folder),
                                         ifelse(!is.null(min_hab_area), 
                                                paste0("_minarea", min_hab_area), ""), "_combined.tif"))
  }  
  
  return(rast_comb)
}
